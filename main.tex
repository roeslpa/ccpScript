\documentclass[a4paper,orivec]{llncs}

\newcommand{\alert}[1]{{\color{red}#1}}

\usepackage{fullpage}
\pagestyle{plain}
\setcounter{tocdepth}{2}

\input{packages}
\input{commands}

\bibliographystyle{alpha}

\makeatletter
\renewcommand*\l@author[2]{}
\renewcommand*\l@title[2]{}
\makeatletter
\renewcommand{\contentsname}{}


\title{Cryptographic Communication Protocols:\\Key Exchange and Channels}
\author{Paul Rösler}

\institute{FAU Erlangen-Nürnberg}

\begin{document}

\maketitle
\begin{center}
    \today
\end{center}

\begingroup
\let\clearpage\relax
\tableofcontents
\endgroup


\input{sections/admin}

\section{Preliminary Remarks}
This document is not (yet) a full course script.
Instead, it is meant as an additional resource that systematizes the considered primitives, definitions, and constructions.
The author invites readers to submit comments or pull requests via the GitHub Repository \url{https://github.com/roeslpa/ccpScript}.

For this course, it is beneficial to be familiar with the content of the introduction to modern cryptography lecture, see lecture notes, ??? or ??? for free.

\section{Notation}

\begin{tabular}{|l|p{13cm}|}\hline
    \textbf{Symbol} & \textbf{Meaning}\\\hline
    $\T$ / $\F$ & Boolean values true and false\\
    $\gets$ / $\to$ & Assigns a constant expression or the output of a deterministic algorithm\\
    $\getsr$ / $\tor$ & Assigns a random value uniformly sampled from a finite set or the output of a probabilistic algorithm\\
    $\PS(X)$ & Power set of set~$X$\\
    $(X)^+$ & Set of non-trivial concatenations of elements from set~$X$\\
    $X[\cdot]\gets x$ & Assigns all entries of array~$X$ with default value~$x$\\
    Invoke $X$ & Executes algorithm $X$\\
    Stop with $x$ & Terminates the running experiment with final output~$x$\\
    Require $x$ & Ends the algorithm, resp.~oracle, if expression~$x=\F$\\\hline
\end{tabular}


\input{sections/overview}


\section{Game-Based Definitions}
As one can see from the minimal differences between the \emph{passive} security definition and the \emph{active} security definition for PKE from Section~\ref{sec:overview:pke}, definitions of security can be modular with respect to a pattern that is based on a small core.
We will use the example of \emph{Key Encapsulation Mechanisms}~(KEM) to introduce a methodology for defining security systematically.
This methodology is closely related to a concept called \emph{Indistinguishability up to Correctness} by Rogaway and Zhang~\cite{C:RogZha18}.

\subsection{Syntax}
The first step to formally consider a cryptographic primitive is defining its \emph{syntax}.
The syntax specifies the algorithms of a primitive by defining their inputs and outputs.

A key encapsulation mechanism $\KEM=(\KEMgen,\KEMenc,\KEMdec)$ is a tuple of three algorithms with encapsulation key space~$\eksp$, decapsulation key space~$\dksp$, ciphertext space~$\csp$, and symmetric key space~$\ksp$:
\begin{itemize}
    \item $\KEMgen: \emptyset \tor \dksp\times\eksp$
    \item $\KEMenc: \eksp \tor \ksp\times\csp$
    \item $\KEMdec: \dksp\times\csp \to \ksp$
\end{itemize}

Intuitively a KEM can be considered a special case of PKE that is limited to always encrypt (aka.\@ encapsulate) fresh symmetric keys.
Instead of taking the symmetric keys as input, the encapsulation algorithm of a KEM generates them internally.

\paragraph{Construction: ElGamal KEM}
For illustration, we give the ElGamal KEM as a simple example of a KEM in Figure~\ref{fig:kem:const:elgamal}.

\begin{figure}[!ht]
    \centering
    \nicoresetlinenr%
    \fbox{%
        \scalebox{\codescalefactor}{%
            \input{figures/kem_const_elgamal}%
        }%
    }
    \caption{%
        ElGamal key encapsulation mechanism~$\KEM$~\cite{ElGamal85}.
    }
    \label{fig:kem:const:elgamal}
\end{figure}

\subsection{Correctness}
Before specifying the expected security guarantees, we define the \emph{correctness} requirements.
Typically, these requirements capture the functionality that a primitive should offer when being executed in an \emph{honest} environment in which all traffic is delivered as intended.
The literature on distributed systems developed two complementary notions of correctness:
\begin{itemize}
    \item \textbf{Safety:} Nothing ``bad'' should happen (e.g., encapsulation and decapsulation for the same ciphertext should not compute different symmetric keys)
    \item \textbf{Liveness:} The ``good'' event always happens (e.g., encapsulation and decapsulation always output a non-trivial key)
\end{itemize}

A correctness definition in the sense of \emph{safety} typically suffices for the ultimate goal of defining and analyzing security.
Furthermore, specifying \emph{liveness} requirements for sophisticated primitives sometimes leads to complex, incomprehensible definitions.

A key encapsulation mechanism $\KEM$ is correct if
\[
\Pr[\KEMdec(\dk,c)=k\mid (\dk,\ek)\getsr\KEMgen,(k,c)\getsr\KEMenc(\ek))=m]=1\text{.}
\]
Equivalently, a key encapsulation mechanism $\KEM$ is correct if $\Pr[\CORR_{\KEM}(\advA)=0]=1$ for all adversaries~$\advA$, where game~$\CORR$ is defined in Figure~\ref{fig:kem:corr}.

\begin{figure}[!ht]
    \centering
    \nicoresetlinenr%
    \fbox{%
        \scalebox{\codescalefactor}{%
            \input{figures/kem_corr}%
        }%
    }
    \caption{%
        Game $\CORR$ for key encapsulation mechanism~$\KEM$.
    }
    \label{fig:kem:corr}
\end{figure}

\subsection{Adversarial Capabilities}
Defining \emph{security} can be divided into three components:
modeling the \emph{capabilities of adversaries},
specifying the \emph{adversaries' goal}, and
identifying attack strategies that are \emph{trivially} successful against every possible construction.
The former two components are typically influenced by intuitive purpose of the considered primitive and how this primitive is used in practice;
the latter one is almost entirely determined by all remaining definitional steps.

\subsubsection{Typical Capabilities}
We begin with considering typical adversarial capabilities against KEMs:
\begin{itemize}
    \item \textbf{Chosen-Plaintext Attacks:}
    The adversary can see the ciphertexts of encapsulated keys
    \item \textbf{Chosen-Ciphertext Attacks:}
    The adversary can see the decapsulated keys for chosen ciphertexts
    \item \textbf{Secret Key Corruption:}
    The adversary can learn the entire decapsulation key
    \item \textbf{Leakage of Information during Algorithm Execution:}
    The adversary can learn secret bits of variables processed by the encapsulation or decapsulation algorithm
    \item \textbf{Subversion of Algorithms:}
    The adversary can modify the encapsulation or decapsulation algorithm
    \item Etc.
\end{itemize}

\paragraph{Chosen-Plaintext Attacks}
The most standard adversarial capabilities that are considered realistic and defendable for KEMs are chosen-plaintext and chosen-ciphertext attacks (CPA resp.\@ CCA).


These notions are essentially the same except that the latter provides an additional decapsulation oracle via which the adversary can query ciphertexts to obtain the encapsulated symmetric keys.



\paragraph{Chosen-Ciphertext Attacks}
To exemplify CPA and CCA definitions, we 

The advantage of an adversary~$\advA$ against key encapsulation mechanism $\KEM$ in game $\INDCCA$ from Figure~\ref{fig:kem:ind} is defined as:
\[
\Adv_\KEM^\indcca(\advA)\coloneqq\left|\Pr[\INDCCA_{\KEM}^0(\advA)=1]-\Pr[\INDCCA_{\KEM}^1(\advA)=1]\right|\text{.}
\]

\begin{figure}[!ht]
    \centering
    \nicoresetlinenr%
    \fbox{%
        \scalebox{\codescalefactor}{%
            \input{figures/kem_ind}%
        }%
    }
    \caption{%
        Games $\INDCCA$ for key encapsulation mechanism~$\KEM$.
    }
    \label{fig:kem:ind}
\end{figure}

\begin{figure}[!ht]
    \centering
    \nicoresetlinenr%
    \fbox{%
        \scalebox{\codescalefactor}{%
            \input{figures/kem_ind_mi_corrupt}%
        }%
    }
    \caption{%
        Multi-instance games $\INDCCA$ for key encapsulation mechanism~$\KEM$.
    }
    \label{fig:kem:ind:mi:corrupt}
\end{figure}

\subsection{Adversarial Goal}

\subsubsection{Typical Goals}

\paragraph{One-Way Security}

\paragraph{Indistinguishability of Ciphertexts}

\subsection{Trivial Winning Strategies}


\section{Symmetric Primitives}


\subsection{Pseudo-Random Generator}


\paragraph{Syntax}
A pseudo-random generator $\PRG=\PRGf$ is an algorithm with key space~$\ksp$ and output space~$\rsp$:

\begin{itemize}
    \item $\PRGf: \ksp \to \rsp$
\end{itemize}

\paragraph{Security}
The advantage of an adversary~$\advA$ against pseudo-random generator $\PRG$ in game $\IND$ from Figure~\ref{fig:prg:ind} is defined as:
\[
\Adv_\PRG^\ind(\advA)\coloneqq\left|\Pr[\IND_{\PRG}^0(\advA)=1]-\Pr[\IND_{\PRG}^1(\advA)=1]\right|\text{.}
\]

\begin{figure}[!ht]
    \centering
    \nicoresetlinenr%
    \fbox{%
        \scalebox{\codescalefactor}{%
            \input{figures/prg_ind}%
        }%
    }
    \caption{%
        Games $\IND$ for pseudo-random generator~$\PRG$.
    }
    \label{fig:prg:ind}
\end{figure}

\subsection{Pseudo-Random Function}

\paragraph{Syntax}
A pseudo-random function $\PRF=\PRFf$ is an algorithm with key space~$\ksp$, input space~$\msp$ and output space~$\rsp$:

\begin{itemize}
    \item $\PRFf: \ksp\times\msp \to \rsp$
\end{itemize}

\paragraph{Security}
The advantage of an adversary~$\advA$ against pseudo-random function $\PRF$ in game $\IND$ from Figure~\ref{fig:prf:ind} is defined as:
\[
\Adv_\PRF^\ind(\advA)\coloneqq\left|\Pr[\IND_{\PRF}^0(\advA)=1]-\Pr[\IND_{\PRF}^1(\advA)=1]\right|\text{.}
\]

\begin{figure}[!ht]
    \centering
    \nicoresetlinenr%
    \fbox{%
        \scalebox{\codescalefactor}{%
            \input{figures/prf_ind}%
        }%
    }
    \caption{%
        Games $\IND$ for pseudo-random function~$\PRF$.
    }
    \label{fig:prf:ind}
\end{figure}

\subsection{Message Authentication Code (MAC)}

\paragraph{Syntax}
A message authentication code $\MAC=(\MACgen,\MACtag,\MACvfy)$ is a tuple of three algorithms with key space~$\ksp$, message space~$\msp$, and tag space~$\tsp$:

\begin{itemize}
    \item $\MACgen: \emptyset \tor \ksp$
    \item $\MACtag: \ksp\times\msp \tor \tsp$
    \item $\MACvfy: \ksp\times\msp\times\tsp \to \Bool$
\end{itemize}

\paragraph{Correctness}
A message authentication code $\MAC$ is correct if
\[
\Pr[\MACvfy(k,m,\MACtag(k,m))=\T\mid k\getsr\MACgen,m\getsr\msp]=1\text{.}
\]

\paragraph{Security: Strong Existential Unforgeability under Chosen-Message Attacks}
The advantage of an adversary~$\advA$ against message authentication code $\MAC$ in game $\SUFCMA$ from Figure~\ref{fig:mac:suf} is defined as:
\[
\Adv_\MAC^\sufcma(\advA)\coloneqq\Pr[\SUFCMA_{\MAC}(\advA)=1]\text{.}
\]

\begin{figure}[!ht]
    \centering
    \nicoresetlinenr%
    \fbox{%
        \scalebox{\codescalefactor}{%
            \input{figures/mac_suf}%
        }%
    }
    \caption{%
        Game $\SUFCMA$ for message authentication code~$\MAC$.
    }
    \label{fig:mac:suf}
\end{figure}


\subsection{Symmetric Encryption (SE)}

\subsubsection{Probabilistic SE}

\paragraph{Syntax}
A probabilistic symmetric encryption scheme $\SYE=(\SYEgen,\SYEenc,\SYEdec)$ is a tuple of three algorithms with key space~$\ksp$, message space~$\msp$, and ciphertext space~$\csp$:

\begin{itemize}
    \item $\SYEgen: \emptyset \tor \ksp$
    \item $\SYEenc: \ksp\times\msp \tor \csp$
    \item $\SYEdec: \ksp\times\csp \to \msp$
\end{itemize}

\paragraph{Correctness}
A symmetric encryption scheme $\SYE$ is correct if 
\[
\Pr[\SYEdec(k,\SYEenc(k,m))=m\mid k\getsr\SYEgen,m\getsr\msp]=1\text{.}
\]
Equivalently, a symmetric encryption scheme $\SYE$ is correct if $\Pr[\CORR_{\SYE}(\advA)=0]=1$ for all adversaries~$\advA$, where game~$\CORR$ is defined in Figure~\ref{fig:sym:enc:corr:prob}.

\begin{figure}[!ht]
    \centering
    \nicoresetlinenr%
    \fbox{%
        \scalebox{\codescalefactor}{%
            \input{figures/sym_enc_corr_prob}%
        }%
    }
    \caption{%
        Game $\CORR$ for probabilistic encryption scheme~$\SYE$.
    }
    \label{fig:sym:enc:corr:prob}
\end{figure}

\paragraph{Security: One-Wayness under Chosen-Ciphertext Attacks}
The advantage of an adversary~$\advA$ against symmetric encryption scheme $\SYE$ in game $\OWCCA$ from Figure~\ref{fig:sym:enc:ow:prob} is defined as:
\[
\Adv_\SYE^\owcca(\advA)\coloneqq\Pr[\OWCCA_{\SYE}(\advA)=1]\text{.}
\]

\begin{figure}[!ht]
    \centering
    \nicoresetlinenr%
    \fbox{%
        \scalebox{\codescalefactor}{%
            \input{figures/sym_enc_ow_prob}%
        }%
    }
    \caption{%
        Game $\OWCCA$ for probabilistic symmetric encryption scheme~$\SYE$.
    }
    \label{fig:sym:enc:ow:prob}
\end{figure}

\paragraph{Security: Indistinguishability under Chosen-Ciphertext Attacks}
The advantage of an adversary~$\advA$ against symmetric encryption scheme $\SYE$ in game $\INDCCA$ from Figure~\ref{fig:sym:enc:ind:prob} is defined as:
\[
\Adv_\SYE^\indcca(\advA)\coloneqq\left|\Pr[\INDCCA_{\SYE}^0(\advA)=1]-\Pr[\INDCCA_{\SYE}^1(\advA)=1]\right|\text{.}
\]

\begin{figure}[!ht]
    \centering
    \nicoresetlinenr%
    \fbox{%
        \scalebox{\codescalefactor}{%
            \input{figures/sym_enc_ind_prob}%
        }%
    }
    \caption{%
        Games $\INDCCA$ for probabilistic symmetric encryption scheme~$\SYE$.
    }
    \label{fig:sym:enc:ind:prob}
\end{figure}


\subsubsection{Authenticated Encryption with Associated Data}

\paragraph{Syntax}
An authenticated encryption scheme with associated data $\AEAD=(\AEADgen,\AEADenc,\AEADdec)$ is a tuple of three algorithms with key space~$\ksp$, message space~$\msp$, associated-data space~$\adsp$, and ciphertext space~$\csp$:

\begin{itemize}
    \item $\AEADgen: \emptyset \tor \ksp$
    \item $\AEADenc: \ksp\times\msp\times\adsp \tor \csp$
    \item $\AEADdec: \ksp\times\adsp\times\csp \to \msp\cup\{\bot\}$
\end{itemize}

\paragraph{Correctness}
An authenticated encryption scheme with associated data $\AEAD$ is correct if 
\[
\Pr[\AEADdec(k,\ad,\AEADenc(k,m,\ad))=m\mid k\getsr\SYEgen,m\getsr\msp,\ad\getsr\adsp]=1\text{.}
\]
Equivalently, an authenticated encryption scheme with associated data $\AEAD$ is correct if $\Pr[\CORR_{\AEAD}(\advA)=0]=1$ for all adversaries~$\advA$, where game~$\CORR$ is defined in Figure~\ref{fig:sym:aenc:corr}.

We define the standard security notions $\INDD$ and $\SUFCMA$ adapted from the seminal work by Rogaway~\cite{CCS:Rogaway02} in the following paragraphs.

\begin{figure}[!ht]
    \centering
    \nicoresetlinenr%
    \fbox{%
        \scalebox{\codescalefactor}{%
            \input{figures/sym_aenc_corr}%
        }%
    }
    \caption{%
        Game $\CORR$ for authenticated encryption scheme with associated data~$\AEAD$.
    }
    \label{fig:sym:aenc:corr}
\end{figure}

\paragraph{Security: Indistinguishability of Ciphertexts from Randomness under Chosen-Plaintext Attacks}
The advantage of an adversary~$\advA$ against authenticated encryption scheme with associated data $\AEAD$ in game $\INDD$ from Figure~\ref{fig:sym:aenc:indd} is defined as:
\[
\Adv_\AEAD^\indd(\advA)\coloneqq\left|\Pr[\INDD_{\AEAD}^0(\advA)=1]-\Pr[\INDD_{\AEAD}^1(\advA)=1]\right|\text{.}
\]

\begin{figure}[!ht]
    \centering
    \nicoresetlinenr%
    \fbox{%
        \scalebox{\codescalefactor}{%
            \input{figures/sym_aenc_indd}%
        }%
    }
    \caption{%
        Games $\INDD$ for authenticated encryption scheme with associated data~$\AEAD$.
    }
    \label{fig:sym:aenc:indd}
\end{figure}

\paragraph{Security: Strong Existential Unforgeability under Chosen-Message Attacks}
The advantage of an adversary~$\advA$ against authenticated encryption scheme with associated data $\AEAD$ in game $\SUFCMA$ from Figure~\ref{fig:sym:aenc:suf} is defined as:
\[
\Adv_\AEAD^\sufcma(\advA)\coloneqq\Pr[\SUFCMA_{\AEAD}^0(\advA)=1]\text{.}
\]

\begin{figure}[!ht]
    \centering
    \nicoresetlinenr%
    \fbox{%
        \scalebox{\codescalefactor}{%
            \input{figures/sym_aenc_suf}%
        }%
    }
    \caption{%
        Game $\SUFCMA$ for authenticated encryption scheme with associated data~$\AEAD$.
    }
    \label{fig:sym:aenc:suf}
\end{figure}




\section{Asymmetric Primitives}
\label{sec:asym}

\subsection{Assumptions}
\label{sec:asym:assumptions}

\subsubsection{Diffie-Hellman (DH)}
\label{sec:asym:assumptions:dh}
Let $\DHgr=(\DHg,\DHp)$ be a group of prime order~$\DHp$ with generator~$\DHg$.

\paragraph{Discrete Logarithm}
The advantage of an adversary~$\advA$ against the discrete logarithm problem in group~$\DHgr$ is defined as:
\[
\Adv_\DHgr^\dlp(\advA)\coloneqq\Pr[\advA(\DHg,\DHp,\DHg^x)=x\mid x\getsr\ZZ_\DHp^*]\text{.}
\]


\paragraph{Computational DH}
The advantage of an adversary~$\advA$ against the computational Diffie-Hellman problem in group~$\DHgr$ is defined as:
\[
\Adv_\DHgr^\cdh(\advA)\coloneqq\Pr[\advA(\DHg,\DHp,\DHg^x,\DHg^y)=,\DHg^{xy}\mid (x,y)\getsr(\ZZ_\DHp^*)^2]\text{.}
\]

\paragraph{Decisional DH}
The advantage of an adversary~$\advA$ against the decisional Diffie-Hellman problem in group~$\DHgr$ is defined as:
\begin{align*}
    \Adv_\DHgr^\ddh(\advA)\coloneqq|&\Pr[\advA(\DHg,\DHp,\DHg^x,\DHg^y,\DHg^{xy})=1\mid (x,y)\getsr(\ZZ_\DHp^*)^2]\\
    &-\Pr[\advA(\DHg,\DHp,\DHg^x,\DHg^y,\DHg^z)=1\mid (x,y,z)\getsr(\ZZ_\DHp^*)^3]|\text{.}
\end{align*}

\subsection{Digital Signature}

\paragraph{Syntax}
A digital signature scheme $\SIG=(\SIGgen,\SIGsig,\SIGvfy)$ is a tuple of three algorithms with signing key space~$\sksp$, verification key space~$\vksp$, message space~$\msp$, and signature space~$\sigsp$:

\begin{itemize}
    \item $\SIGgen: \emptyset \tor \sksp\times\vksp$
    \item $\SIGsig: \sksp\times\msp \tor \sigsp$
    \item $\SIGvfy: \vksp\times\msp\times\sigsp \to \Bool$
\end{itemize}

\paragraph{Correctness}
A digital signature scheme $\SIG$ is correct if
\[
\Pr[\SIGvfy(\vk,m,\SIGsig(\sk,m))=\T\mid (\sk,\vk)\getsr\SIGgen,m\getsr\msp]=1\text{.}
\]

\paragraph{Security}
The advantage of an adversary~$\advA$ against digital signature scheme $\SIG$ in game $\SUFCMA$ from Figure~\ref{fig:sig:suf} is defined as:
\[
\Adv_\SIG^\sufcma(\advA)\coloneqq\Pr[\SUFCMA_{\SIG}(\advA)=1]\text{.}
\]

\begin{figure}[!ht]
    \centering
    \nicoresetlinenr%
    \fbox{%
        \scalebox{\codescalefactor}{%
            \input{figures/sig_suf}%
        }%
    }
    \caption{%
        Game $\SUFCMA$ for digital signature scheme~$\SIG$.
    }
    \label{fig:sig:suf}
\end{figure}

\subsection{Identity-Based KEM}

\paragraph{Syntax}
An identity-based KEM $\IKEM=(\IKEMgen,\IKEMenc,\IKEMdel,\IKEMdec)$ is a tuple of four algorithms with encapsulation key space~$\eksp$, decapsulation key space~$\dksp$, identity space~$\idsp$, ciphertext space~$\csp$, and symmetric key space~$\ksp$:

\begin{itemize}
    \item $\IKEMgen: \emptyset \tor \dksp\times\eksp$
    \item $\IKEMenc: \eksp\times(\idsp)^+ \tor \ksp\times\csp$
    \item $\IKEMdel: \dksp\times\idsp \tor \dksp$
    \item $\IKEMdec: \dksp\times\csp \to \ksp$
\end{itemize}


\section{Stateful Primitives}

\subsection{Forward-Secure KEM}

\paragraph{Syntax}
A forward-secure KEM $\FKEM=(\FKEMgen,\FKEMenc,\FKEMdec)$ is a tuple of three algorithms with encapsulation key space~$\eksp$, decapsulation key space~$\dksp$, ciphertext space~$\csp$, and symmetric key space~$\ksp$:

\begin{itemize}
    \item $\FKEMgen: \emptyset \tor \dksp\times\eksp$
    \item $\FKEMenc: \eksp \tor \ksp\times\csp$
    \item $\FKEMdec: \dksp\times\csp \to \dksp\times\ksp$
\end{itemize}

\paragraph{Correctness}
A forward-secure KEM $\FKEM$ is correct if $\Pr[\CORR_{\FKEM}(\advA)=0]=1$ for all adversaries~$\advA$, where game~$\CORR$ is defined in Figure~\ref{fig:fkem:corr}.

\begin{figure}[!ht]
    \centering
    \nicoresetlinenr%
    \fbox{%
        \scalebox{\codescalefactor}{%
            \input{figures/fkem_corr}%
        }%
    }
    \caption{%
        Game $\CORR$ for forward-secure KEM~$\FKEM$.
    }
    \label{fig:fkem:corr}
\end{figure}

\paragraph{Security}
The advantage of an adversary~$\advA$ against forward-secure KEM $\FKEM$ in game $\INDCCA$ from Figure~\ref{fig:fkem:ind} is defined as:
\[
\Adv_\FKEM^\indcca(\advA)\coloneqq\left|\Pr[\INDCCA_{\FKEM}^0(\advA)=1]-\Pr[\INDCCA_{\FKEM}^1(\advA)=1]\right|\text{.}
\]

\begin{figure}[!ht]
    \centering
    \nicoresetlinenr%
    \fbox{%
        \scalebox{\codescalefactor}{%
            \input{figures/fkem_ind}%
        }%
    }
    \caption{%
        Games $\INDCCA$ for forward-secure KEM~$\FKEM$.
    }
    \label{fig:fkem:ind}
\end{figure}

\paragraph{Construction}


\subsection{Updatable KEM}

\paragraph{Syntax}
An updatable KEM $\UKEM=(\UKEMgen,\UKEMenc,\UKEMdec)$ is a tuple of three algorithms with encapsulation key space~$\eksp$, decapsulation key space~$\dksp$, ciphertext space~$\csp$, and symmetric key space~$\ksp$:

\begin{itemize}
    \item $\UKEMgen: \emptyset \tor \dksp\times\eksp$
    \item $\UKEMenc: \eksp \tor \eksp\times\ksp\times\csp$
    \item $\UKEMdec: \dksp\times\csp \to \dksp\times\ksp$
\end{itemize}

\paragraph{Construction}


\subsection{Key Exchange}

\subsubsection{Two-Pass Key Exchange}

\paragraph{Syntax}
A two-pass key exchange $\TKE=(\TKEsnd,\TKErsp,\TKErcv)$ is a tuple of three algorithms with state space~$\stsp$, initial ciphertext space~$\csp_I$, response ciphertext space~$\csp_R$, and symmetric key space~$\ksp$:

\begin{itemize}
    \item $\TKEsnd: \emptyset \tor \stsp\times\csp_I$
    \item $\TKErsp: \csp_I \tor \ksp\times\csp_R$
    \item $\TKErcv: \stsp\times\csp_R \to \ksp$
\end{itemize}

\paragraph{Construction: DH Key Exchange}

\paragraph{Construction: X3DH}

\subsubsection{Authenticated Key Exchange}

\paragraph{Syntax}
An authenticated key exchange $\AKE=(\AKEgen,\allowbreak\AKEsnd,\allowbreak\AKErsp_R,\allowbreak\AKErsp_I,\allowbreak\AKErcv)$ is a tuple of five algorithms with secret key space~$\sksp$, public key space~$\pksp$, state space~$\stsp$, ciphertext space~$\csp$, and symmetric key space~$\ksp$:

\begin{itemize}
    \item $\AKEgen: \emptyset \tor \sksp\times\pksp$
    \item $\AKEsnd: \sksp\times\pksp \tor \stsp\times\csp$
    \item $\AKErsp_R: \sksp\times\csp \tor \stsp\times\csp$
    \item $\AKErsp_I: \sksp\times\stsp\times\csp \tor \ksp\times\csp$
    \item $\AKErcv: \sksp\times\stsp\times\csp \to \pksp\times\ksp$
\end{itemize}

\paragraph{Construction: Signature-Based Authentication}

\paragraph{Construction: KEM-Based Authentication}

\paragraph{Construction: TLS}

\paragraph{Construction: Noise Framework}


\subsection{Ratcheted Key Exchange (RKE)}

\subsubsection{Unidirectional RKE}

\paragraph{Syntax}
A unidirectional key exchange $\URKE=(\URKEinit,\URKEsnd,\URKErcv)$ is a tuple of three algorithms with state space~$\stsp$, ciphertext space~$\csp$, and symmetric key space~$\ksp$:

\begin{itemize}
    \item $\URKEinit: \emptyset \tor \stsp\times\stsp$
    \item $\URKEsnd: \stsp \tor \stsp\times\ksp\times\csp$
    \item $\URKErcv: \stsp\times\csp \to \ksp$
\end{itemize}

\paragraph{Construction}

\subsubsection{Sesquidirectional RKE}

\subsubsection{Bidirectional RKE}

\paragraph{Construction: Double Ratchet}

\subsubsection{Group RKE}

\paragraph{Construction: Sender Key Mechanism}

\paragraph{Construction: Tree-Based DH}

\paragraph{Construction: Tree KEM}

\bibliography{cryptobib/abbrev3,cryptobib/crypto}

\end{document}